(locally (declare (optimize speed))
  (defun string-mid (str idx &optional (len -1))
	(declare (type string str))
	(declare (type fixnum idx len))
	(if (< len 0)
		(subseq str idx)
		(subseq str idx (+ idx len)))))

; example : (string/split "abc,def,ghi" #\,) => ("abc" "def" "ghi")
(locally (declare (optimize speed))
	(defun split-string (line separator)
	  (declare (type string line))
	  (let ((acc nil))
		(do ((idx1 0)
			 (idx2 0))
			((null idx1) (nreverse acc))
		  (setf idx2 (position separator line :start idx1))
		  (if (null idx2)
			  (push (string-mid line idx1) acc)
			  (progn
				(push (string-mid line idx1 (- idx2 idx1)) acc)
				(incf idx2)))
		  (setf idx1 idx2)))))
  
(defun ignore-word-p (word)
  (or (= 1 (length word))
	  (string= word "at")
	  (string= word "in")
	  (string= word "of")
	  (string= word "or")
	  (string= word "and")
	  (string= word "for")
	  (string= word "over")
	  (string= word "with")
	  (string= word "emoji")
	  (string= word "small")
	  (string= word "medium")
	  (string= word "large")))


(defun fixup-data (infile)
  (let ((result nil))
	(labels ((recur (lst acc)
			   (if (null lst)
				   (remove-duplicates (sort acc #'string<) :test #'string=)
				   (let ((word (car lst)))
					 (unless (ignore-word-p word)
					   (push word acc))
					 (recur (cdr lst) acc)))))
	  (dolist (entry (with-open-file (in infile)
					   (read in)))
		(destructuring-bind (code name) entry
		  (if (null (position #\- name))
			  (push entry result)
			  (let ((lst (recur (split-string name #\-) nil)))
				(push (cons code (cons name lst)) result))))))
	(nreverse result)))

  
(with-open-file (out "./06.emoji.data" :direction :output :if-exists :supersede)
  (format out ";;-*-MODE:lisp-*-~%")
  (format out "(~%")
  (dolist (entry (fixup-data "./06.emoji.tmp"))
	(format out "(#x~X" (car entry))
	(dolist (word (cdr entry))
	  (format out " ~S" word))
	(format out ")~%"))
  (format out ")~%"))
	
  
